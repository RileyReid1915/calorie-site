<script>
  (function () {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 600 / 300, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(600, 300);
    document.getElementById('3d-container').appendChild(renderer.domElement);

    let model;
    let targetMesh;

    const light = new THREE.AmbientLight(0xffffff, 1);
    scene.add(light);

    const loader = new THREE.GLTFLoader();
    loader.load(
      'https://raw.githubusercontent.com/RileyReid1915/3d-models/main/human.glb',
      (gltf) => {
        model = gltf.scene;
        scene.add(model);

        targetMesh = findMeshWithShapeKeys(model);

        if (targetMesh) {
          console.log('Знайдено mesh із shape keys:', targetMesh);
          setupSliders(targetMesh);
        } else {
          console.warn('Не вдалося знайти mesh із shape keys.');
        }

        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center);

        const size = box.getSize(new THREE.Vector3());
        camera.position.z = Math.max(size.x, size.y, size.z) * 2;
        camera.lookAt(0, 0, 0);

        animate();
      },
      undefined,
      (error) => {
        console.error('Помилка завантаження моделі:', error);
      }
    );

    function findMeshWithShapeKeys(object) {
      let mesh = null;
      object.traverse((child) => {
        console.log('Перевіряємо об\'єкт:', child.name);
        if (child.morphTargetInfluences) {
          console.log('Знайдено shape keys у:', child.name);
          mesh = child;
        }
      });
      return mesh;
    }

    function setupSliders(mesh) {
      document.getElementById('weight-slider').addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        mesh.morphTargetInfluences[1] = value / 200;
        console.log('Вага:', value, 'Morph Influence key2:', mesh.morphTargetInfluences[1]);
      });

      document.getElementById('height-slider').addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        mesh.morphTargetInfluences[0] = value / 220;
        console.log('Зріст:', value, 'Morph Influence key1:', mesh.morphTargetInfluences[0]);
      });

      document.getElementById('age-slider').addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        mesh.morphTargetInfluences[2] = value / 65;
        console.log('Вік:', value, 'Morph Influence key3:', mesh.morphTargetInfluences[2]);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      if (model) model.rotation.y += 0.01;
      renderer.render(scene, camera);
    }

    document.getElementById('calorie-form').addEventListener('submit', async (e) => {
      e.preventDefault();

      const weight = parseFloat(document.getElementById('weight-slider').value);
      const height = parseFloat(document.getElementById('height-slider').value);
      const age = parseInt(document.getElementById('age-slider').value);
      const gender = document.getElementById('gender').value;

      try {
        const response = await fetch('https://calorie-api-n8u8.onrender.com/api/calculate-calories', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ weight, height, age, gender })
        });

        if (!response.ok) throw new Error('Помилка при запиті до API');

        const data = await response.json();
        document.getElementById('result').innerText = `Добова норма калорій: ${data.daily_calories} ккал`;
      } catch (error) {
        document.getElementById('result').innerText = 'Сталася помилка: ' + error.message;
      }
    });
  })();
</script>
